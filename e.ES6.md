# let&const
### let
用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。**let实际上为 JavaScript 新增了块级作用域。**
- for循环 所以每一次循环的i其实都是一个新的变量，JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。
- for循环 设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。
- 没有变量提升
- 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。
  -  暂时性死区”也意味着typeof不再是一个百分之百安全的操作。
- let不允许在相同作用域内，重复声明同一个变量。

### 块级作用域
- es6允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。
**不同浏览器实现不同，环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。**
- 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。

### do 表达式（提案）
本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。
在块级作用域之前加上do，使它变为do表达式 使得块级作用域可以变为表达式，也就是说可以返回值。

### const
const声明一个只读的常量。一旦声明，常量的值就不能改变。  
对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。  
对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，数据结构可变
- 块级作用域有效
- 暂时性死区
- Object.freeze方法，将对象冻结
```
const foo = Object.freeze({});
```
# function
### 默认参数
ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。
```
function log(x, y = 'World') {
  console.log(x, y);
}
```
- 参数默认值不是传值的，而是每次都重新计算默认值表达式的值。
- 参数默认值可以与解构赋值的默认值，结合起来使用。
```
function foo({x, y = 5}) {
  console.log(x, y);
}

foo({}) // undefined, 5
foo({x: 1}) // 1, 5
foo({x: 1, y: 2}) // 1, 2
foo() // TypeError: Cannot read property 'x' of undefined
```
- **定义了默认值的参数**，应该是函数的尾参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。(需要设为undefined)
### length
指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。  
length属性的含义是，该函数预期传入的参数个数。同理，rest 参数也不会计入length属性。









